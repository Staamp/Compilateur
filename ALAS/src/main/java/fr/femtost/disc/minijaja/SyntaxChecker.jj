PARSER_BEGIN(SyntaxChecker)
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import fr.femtost.disc.minijaja.ast.*;
import fr.femtost.disc.minijaja.ast.expr.identificateur.*;
import fr.femtost.disc.minijaja.ast.expr.*;
import fr.femtost.disc.minijaja.ast.type.*;
import fr.femtost.disc.minijaja.ast.listexpr.*;
public class SyntaxChecker {
    public static void main(String[] args) {
	System.out.println(args[0]);
	if (args[0].equals("-f"))
	{

	try {
            new SyntaxChecker(new BufferedReader(new FileReader(args[1]))).S();
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            System.out.println("Syntax check failed: " + e.getMessage());
        }
	}else{

        try {
            new SyntaxChecker(new java.io.StringReader(args[0])).S();
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            System.out.println("Syntax check failed: " + e.getMessage());
        }
	}
    }
}

PARSER_END(SyntaxChecker)

 SKIP:  { " " | <"\t"> | <"\n"> | <"\r">|<COM1: ("//" (~["\r", "\n"])*)> | <COM2:("/*"(~["*"] | "*"~["/"])*"*/")> }
TOKEN: {
	<CLASS: "class"(" ")>{ System.out.println("Déclaration d'une nouvelle classe");} |
	<VOID: "void ">{System.out.println("Déclaration d'une instance void");}|
	<ACCG: "{">{System.out.println("Ouverture d'une accolade");}|
	<ACCD: "}">{System.out.println("Fermeture d'une accolade");}|
	<PV: ";">{System.out.println("Point virgule");}|
	<PARRG: "(">{System.out.println("Ouverture d'une parenthèse");}|
	<PARRD :")">{System.out.println("Fermeture d'une parenthèse");}|
	<MAIN:"main ">{System.out.println("Méthode principale");}|
	<FINAL:"final ">{System.out.println("méthode ou variable final");}|
	<RETURN: "return ">{System.out.println("retour attendu");}|
	<EGAL: "=">{System.out.println("Affectation");}|
	<TABG: "[">{System.out.println("Ouverture de crochets");}|
	<TABD: "]">{System.out.println("Fermeture de crochets");}|
	<WRITE: "write">{System.out.println("La console doit écrire");}|
	<WRITELN: "writeln">{System.out.println("La console doit écrire puis revenir à la ligne");}|
	<IF: "if">{System.out.println("Si");}|
	<ELSE: "else">{System.out.println("Sinon");}|
	<WHILE: "while">{System.out.println("Tant que");}|
	<PEG: "+=">{System.out.println("Est égal à la valeur plus 1");}|
	<PP: "++">{System.out.println("Incrémentation");}|
	<OU: "||">{System.out.println("Ou");}|
	<ET: "&&">{System.out.println("Et");}|
	<EXCL: "!">{System.out.println("Point d'exclamation");}|
	<EGEG : "==">{System.out.println("Est égal à ");}|
	//<INF>|
	<SUP : ">">{System.out.println("Est supérieur à");}|
	<PLUS : "+">{System.out.println("Addition");}|
	<MOINS : "-">{System.out.println("Soustraction");}|
	<MULT : "*">{System.out.println("Multiplication");}|
	<DIV : "/">{System.out.println("Division");}|
	<VRAI: "true">{System.out.println("Vrai");}|
	<FAUX: "false">{System.out.println("Faux");}|
	<TYPE: "int " | "boolean ">{ System.out.println("Type de la variable : "+ matchedToken.image);} |
	<ENTIER: "int">{ System.out.println("Type entier");} |
	<BOOL: "boolean">{ System.out.println("Type booleen");} |
	<VIRGULE: ",">{} |

	<IDENT: ((["a"-"z"])+|(["A"-"Z"])+)((["a"-"z"])*(["A"-"Z"])*(["0"-"9"])*)>{ System.out.println("Identificateur :"+ matchedToken.image);} |//Commence forcément par une lettre majuscule ou minuscule, modifiable
	//<TypeMeth: "void" | <TYPE>>{ System.out.println("Type de la méthode : "+ matchedToken.image);} |
	<STRING:("\""(~["\""])*"\"")>{ System.out.println("Chaine de caractères :"+ matchedToken.image);}|
	<NOMBRE: (["0"-"9"])+>{ System.out.println("Entier :"+ matchedToken.image);}
}

void S(): {} {<CLASS> <IDENT> <ACCG> Decls() Methmain() <ACCD> <EOF>  }
void Decls(): {} {Decl()<PV>Decls()| {} }
//void Decl(): {} {Var() | Methode()}
void Decl(): {} {TypeMeth() DeclP() | <FINAL> TypeMeth() <IDENT>Vexp()}
void DeclP(): {} {<IDENT>(<PARRG>Entetes()<PARRD><ACCG>Vars() Instrs()<ACCD>| <TABG> Exp()<TABD>|Vexp())}
void Vars(): {} {Var()<PV>Vars()|{}}
//void Var(): {} {TypeMeth()<IDENT> Vexp() | TypeMeth()<TABG>Exp()<TABD> | "final "<TYPE> <IDENT>Vexp() } /*pb de factorisation*/
void Var(): {} {TypeMeth()  VarP() | <FINAL> TypeMeth() <IDENT>Vexp() }
void VarP(): {} {<IDENT>(<TABG> Exp()<TABD>|Vexp())}//On a inversé les deux parties du ou logique et ça marche miraculeusement
void Vexp(): {} {<EGAL>Exp()|{}}
void Methode(): {} {TypeMeth() <IDENT><PARRG>Entetes()<PARRD><ACCG>Vars() Instrs()<ACCD>}
void Methmain(): {} {<MAIN> <ACCG> Vars() Instrs()<ACCD>}
//void Entetes(): {} { Entete() <VIRGULE> Entetes() | Entete() | {}}
void Entetes(): {} {Entete() EntetesP() | {}}
void EntetesP() : {} {<VIRGULE> Entetes() | {}}
void Entete(): {} {<TYPE><IDENT>}
void Instrs(): {} { Instr() <PV> Instrs() | {}}
//void Instr(): {} {Ident1() <EGAL> Exp() | Ident1() <PEG> Exp() | Ident1() <PP> | <IDENT><PARRG> Listexp() <PARRD> | <RETURN> Exp() | <WRITE> <PARRG> <IDENT> | <STRING> */<PARRD> | <WRITELN> <PARRG> <IDENT> | <STRING> */<PARRD> | <IF> Exp() <ACCG> Instrs() <ACCD> ( <ELSE><ACCG> Instrs() <ACCD> )? | <WHILE> <PARRG> Exp() <PARRD> <ACCG>Instrs()<ACCD> }
void Instr(): {} {<IDENT>((Ident1()InstrP())|<PARRG> Listexp() <PARRD>) | <RETURN> Exp() | <WRITE> <PARRG> (<IDENT> | <STRING>) <PARRD> | <WRITELN> <PARRG> (<IDENT> | <STRING>) <PARRD> | <IF> Exp() <ACCG> Instrs() <ACCD> ( <ELSE><ACCG> Instrs() <ACCD> )? | <WHILE> <PARRG> Exp() <PARRD> <ACCG>Instrs()<ACCD> }
void InstrP(): {} {<EGAL> Exp() | <PEG> Exp() | <PP>}


//void Listexp(): {} {Exp() <VIRGULE> Listexp() | Exp() | {}}
ASTListExpr Listexp(): {ASTListExpr ls; ASTExpr e;} {
    e = Exp() ls = ListexpP() {return new ExChain(e, ls);}
    | {return new Exnil();}
}

ASTListExpr ListexpP(): {ASTListExpr ls;} {
    <VIRGULE> ls = Listexp() {return ls;}
    | {return new Exnil();}
}


//void Exp(): {} {<EXCL> Exp1() | Exp() <ET> Exp1() | Exp() <OU> Exp1() | Exp1()} /*pb rec à gauche*/
ASTExpr Exp(): {ASTExpr result;}{
    <EXCL> result = Exp1() {result = new Not(result);} result = ExpP(result) {return result;}
    | result = Exp1() result = ExpP(result) {return result;}
}//corrige la rec à gauche de Exp => à vérifier

ASTExpr ExpP(ASTExpr left) : {ASTExpr result;} {
    <ET> result = Exp1() {result = new And(left, result);} result = ExpP(result) {return result;}
    | <OU> result = Exp1() {result = new Or(left, result);} result = ExpP(result) {return result;}
    | {return left;}
} //corrige la rec à gauche de Exp => à vérifier


//void Exp1(): {} {Exp1() <EGEG> Exp2() | Exp1() <SUP> Exp2() | Exp2()}/*pb rec à gauche*/
ASTExpr Exp1(): {ASTExpr expr;}{
    expr = Exp2() expr = Exp1P(expr) {return expr;}
}//corrige la rec à gauche de Exp1 => à vérifier

ASTExpr Exp1P(ASTExpr left) : {ASTExpr result;}{
    <EGEG> result = Exp2() {result = new Egal(left, result);} result = Exp1P(result) {return result;}
    | <SUP> result = Exp2() {result = new Superieur(left, result);} result = Exp1P(result) {return result;}
    | {return left;}
}//corrige la rec à gauche de Exp1 => à vérifier


//void Exp2(): {} {Exp2() <PLUS> Terme() | Exp2() <MOINS> Terme() | Terme()}/*pb rec à gauche*/
ASTExpr Exp2(): {ASTExpr expr;} {
    expr = Terme() expr = Exp2P(expr) {return expr;}
}//corrige la rec à gauche de Exp2 => à vérifier

ASTExpr Exp2P(ASTExpr left): {ASTExpr result;} {
    <PLUS> result = Terme() {result = new Addition(left, result);} result = Exp2P(result) {return result;}
    | <MOINS> result = Terme() {result = new Soustraction(left, result);} result = Exp2P(result) {return result;}
    | {return left;}
}//corrige la rec à gauche de Exp2 => à vérifier


//void Terme(): {} {Terme() <MULT> Fact() | Terme() <DIV> Fact() | Fact()}/*pb rec à gauche*/
ASTExpr Terme(): {ASTExpr expr;}{
    expr = Fact() expr = TermeP(expr) {return expr;}
}//corrige la rec à gauche de Exp2 => à vérifier

ASTExpr TermeP(ASTExpr left): {ASTExpr result;}{
    <MULT> result = Fact() {result = new Multiplication(left, result);} result = TermeP(result) {return result;}
    | <DIV> result = Fact() {result = new Division(left, result);} result = TermeP(result) {return result;}
    | {return left;}
}//corrige la rec à gauche de Exp2 => à vérifier

ASTExpr Fact(): {Token t; ASTExpr e;} {
    t = <IDENT> e = FactP(t) {return e;}
    |<VRAI> {return new BoolVal(true);}
    |<FAUX> {return new BoolVal(false);}
    |t = <NOMBRE> {return new Nbre(Integer.parseInt(t.image));}
    |<PARRG> e = Exp()<PARRD> {return e;}
}

ASTExpr FactP(Token t): {ASTExpr e; ASTListExpr ls;}{
    <TABG> e = Exp() <TABD> {return new Tableau(t.image, e);}
    | <PARRG> ls = Listexp() <PARRD> {return new AppelE(new Identifiant(t.image), ls);}
    | {return new Identifiant(t.image);}
}

ASTExpr Ident1(): {ASTExpr expression;} {
      <TABG> expression = Exp() <TABD> {return expression;}
    | {return null;}
}

ASTTypeMeth TypeMeth(): {ASTType t;} {
    <VOID> { return new fr.femtost.disc.minijaja.ast.type.Void();}
    | t = Type() { return t; }
}

ASTType Type(): {} {
    <ENTIER> {return new Entier();}
    | <BOOL> {return new Booleen();}
}